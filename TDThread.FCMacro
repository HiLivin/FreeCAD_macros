"""
This Macro is intended to be used in the TechDraw Workbench,
to find the intersection point of two Edges inside a DrawViewPart.

Select two Egdes and run the Macro. The cosmetic vertex will be created
at the intersection point.
"""

__Name__ = 'TDEdgeIntersection'
__Comment__ = 'Inserts a cosmetic vertex at the position where two lines intersect'
__Author__ = 'Sebastian Bachmann'
__Version__ = '1.0'
__Date__ = '2020-05-07'
__License__ = 'MIT'
__Web__ = 'https://github.com/reox/FreeCAD_Macros'
__Wiki__ = ''
__Icon__ = 'icons/EdgeIntersection.svg'
__Help__ = 'Select two straight lines and run the macro'
__Status__ = 'Stable'
__Requires__ = '>=0.19.20943; py3 only'
__Communication__ = 'https://github.com/reox/FreeCAD_Macros/issues'


# Copyright (c) 2019, Sebastian Bachmann <hello@reox.at>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


import numpy as np
from PySide.QtGui import QMessageBox
from PySide import QtCore

import TechDraw


def msg(title, message):
    diag = QMessageBox(QMessageBox.Warning, title, message)
    diag.setWindowModality(QtCore.Qt.ApplicationModal)
    diag.exec_()


def find_intersection():
    """
    Finds the intersection point of two edges
    And creates a cosmetic vertex there
    """
    # Get the current view:
    cur_view = Gui.Selection.getSelectionEx()[0].Object

    if not cur_view.isDerivedFrom("TechDraw::DrawViewPart"):
        msg("Wrong Selection", "Must select Edges of DrawViewPart!")
        return

    # Get the names of the selected edges:
    elem = Gui.Selection.getSelectionEx()[0].SubElementNames

    try:
        indices = map(lambda x: int(x.replace('Edge', '')), elem)
    except ValueError as e:
        msg("Something is wrong", "Can not parse Edge indices: {}".format(e))
        return

    for i in indices:
        curve = cur_view.getEdgeByIndex(i).Curve

        center = curve.Location
        radius = curve.Radius

        thread_depth = 2
        offset = 5

        # DIN ISO 6410-1:1993: 3/4 circle, opening and position variable
        # Line style: 01.1 (full line, small)
        edge = cur_view.makeCosmeticCircleArc(center, radius + thread_depth, 110, 20)

        x = cur_view.getCosmeticEdge(edge)
        x.Format = (1, cur_view.ViewObject.IsoWidth, (0.0, 0.0, 0.0, 1.0), True)
        # Replace Edge
        rc = cur_view.replaceCosmeticEdge(x)



        r_vec = App.Vector(radius + thread_depth, 0, 0)

        # Create attachment points for thread dimension
        def conv(v):
            return App.Vector(v.x, -v.y, v.z) * cur_view.Scale

        v1 = center + r_vec
        v2 = center - r_vec
        # cur_view.makeCosmeticVertex(v1)
        # cur_view.makeCosmeticVertex(v2)

        # FIXME: Soon, there will be no need for conversion
        TechDraw.makeDistanceDim(cur_view, 'DistanceX', conv(v1), conv(v2))
        dim = cur_view.InList[-1]
        dim.X = center.x * cur_view.Scale
        # TODO: something is off here..
        dim.Y = (-center.y + (radius + offset)) * cur_view.Scale
        dim.Arbitrary = True
        dim.FormatSpec = 'M16'



        # TODO create centermark
        e = cur_view.makeCosmeticLine(center + App.Vector(0, radius + offset), center - App.Vector(0, radius + offset))
        x = cur_view.getCosmeticEdge(e)
        # Center marks are 04.1 --> dash dot small
        x.Format = (4, cur_view.ViewObject.IsoWidth, (0.0, 0.0, 0.0, 1.0), True)
        cur_view.replaceCosmeticEdge(x)

        e = cur_view.makeCosmeticLine(center + App.Vector(radius + offset, 0), center - App.Vector(radius + offset, 0))
        x = cur_view.getCosmeticEdge(e)
        x.Format = (4, cur_view.ViewObject.IsoWidth, (0.0, 0.0, 0.0, 1.0), True)
        cur_view.replaceCosmeticEdge(x)



    # Recompute
    App.activeDocument().recompute(None,True,True)


if __name__ == "__main__":
    find_intersection()
